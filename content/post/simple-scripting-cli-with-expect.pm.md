+++
title = "Simple scripting CLI with Expect.pm"
date = 2012-03-04T02:04:00Z
updated = 2012-03-11T17:19:52Z
tags = [ "perl", "expect"]
blogimport = true 
type = "post"
+++

<p>Expect is use primarily for sending Input to Command Line programs that Prompt and wait for input. For starters you'll need an executable script and I've pasted one that I got elsewhere for a demo. <script src="https://gist.github.com/1970845.js?file=agencolor.pl"></script><noscript><pre><code>#!/usr/bin/env perl<br /># slightly modified from http://www.tizag.com/perlT/perluserinput.php<br />use 5.014;;<br />use warnings;<br /><br /><br />print "How old are you?";<br />my $age = <>;<br /><br />print "What is your favorite color?";<br />my $color = <>;<br /><br />say "You are $age, and your favorite color is $color.";</code></pre></noscript> It's trivial, you should probably run it just to see what it does. Now take a look at our Expect Script.</p> <script src="https://gist.github.com/1970845.js?file=expect.pl"></script><noscript><pre><code>#!/usr/bin/env perl<br />use 5.014;<br />use warnings;<br /><br />use Expect;<br />use List::AllUtils qw( natatime );<br /><br />my @cmd = ( './agencolor.pl' ); # spawn takes command plus argumements<br />my @params = ( '34', 'hot pink' );<br />my @oparams = ( qw( 43 blue ) );<br /><br />my $param  = natatime 1, @params; # iterator<br />my $oparam = natatime 1, @params; # iterator<br /><br />my $exp = Expect->new;<br />$exp->exp_internal( 1 ); # print better debug than ->debug( 3 )<br />$exp->spawn( @cmd );<br /><br />$exp->expect(<br /> 1, # timeout in seconds<br /><br /> # both regex's will try to match for every line<br /> [ qr/\?$/, sub { $exp->send( $param->() . "\n" ); exp_continue; }, ],<br /> [ qr/:$/, sub { $exp->send( $oparam->() . "\n" ); exp_continue; }, ],<br /> # the above line will never match<br />);<br /><br />say '-'x 10;<br />say $exp->before;</code></pre></noscript> <p>Although you can read the comments yourself, let's go over it anyways. <code>->spawn</code> takes a list of arguments, with the first being a command, and the rest being any command line arguments, or options passed to said script. I could have easily just put the command in spawn, but I though I'd show a more dynamic example. After that you'll notice I've hard coded 2 sets of params that could possibly be fed into the program. I also have created some 1 at a time iterators, this simply makes it easier to iterate them in expect. Now onto the Expect object itself.</p> <p>If you've read the documentation you'll notice there are 3 debug settings, with 3 being the most verbose, and some verbose settings. None of this appeared to be as verbose as I could get, however turning on <code>->exp_internal(1);</code> printed everything I needed to understand expect and debug what I was doing wrong. The <code>->spawn</code> method of course forks and execs our command, the output of which then gets iterated by <code>->expect</code>.</p> <p>The first argument to <code>->expect</code> is the timeout, which is measured in seconds. The timeout is how long expect will wait for the output to match one of the regexes. You could set it to <code>undef</code> if you want to wait forever, or if it's just a program that has some startup time before it prompts set it to a few seconds. The timeout will (by default) be used again in between each prompt.</p> <p>After timeout you can specify a list of array refs, each of which has 2 elements. The first is a regular expression that will allow you to tell expect how to recognize a prompt. The second is a coderef which allows you to tell expect what to do if it's corresponding match is hit. Both regexes will be run against every line, checking to see if they match.</p> <p>Inside of our coderef we can use <code>->send</code> to send input to the prompt. Remember <code>send</code> doesn't automatically press enter, so be sure to add your newlines. <code>exp_continue</code> means after match continue using this <code>->expect</code> call to try to match the next line.</p> <p>When running the script you'll notice the second regex never matches, but if reading the 'internal' output you'll see that it is attempting to.</p> <p>The last line is a call to <code>->before</code> which in this case, not very intuitively prints everything that was in the pty after the last match, or more appropriately, before the program exited. You'll also notice that it collects the thing that you sent to the last match.</p> <p>That's the basics of what I've discovered, I'm not sure I fully understand how it all works yet (which means my explanations might not be 100% correct), but perhaps me writing this will help someone else get started with Expect. Happy Hacking! </p><div class="blogger-post-footer"><br />--<br />
This <span xmlns:dc="http://purl.org/dc/elements/1.1/" href="http://purl.org/dc/dcmitype/Text" rel="dc:type">work</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://www.xenoterracide.com" property="cc:attributionName" rel="cc:attributionURL">Caleb Cushing</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.</div>
