+++
title = "New Module: MooseX::RemoteHelper (RFC)"
date = 2012-06-04T06:00:00Z
updated = 2012-06-04T06:00:03Z
tags = ["SOAP::Lite", "data transfer object",  "perl", "design patterns", "remote facade", "XML::Compile::SOAP", "composite"]
blogimport = true 
type = "post"
+++

<h2>Background</h2><p>I have spent much of the last year writing and refining <a href="http://martinfowler.com/eaaCatalog/remoteFacade.html">Remote Facades</a>. At this point I've worked with SOAP, REST/JSON, and RPC url-form-encoded API's. One of the hardest parts I've found is dealing with the serialization of a <a href="http://martinfowler.com/eaaCatalog/dataTransferObject.html">Data Transfer Object</a> with a Perl interface into whatever the remote is expecting. When I started I didn't know of these patterns, or really anything about these patterns. I highly recommend reading <a href="http://www.amazon.com/gp/product/0321127420/ref=as_li_ss_tl?ie=UTF8&tag=xenotsblog-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0321127420">Patterns of Enterprise Application Architecture</a><img src="http://www.assoc-amazon.com/e/ir?t=xenotsblog-20&l=as2&o=1&a=0321127420" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />) if you want to know more about these patterns or things like Active Record and MVC.</p><h3>problem</h3><p>The problems I've encountered are many, including the fact most remotes are buggy or have a cludgy interface. Though there's nothing you can do about a remote api that you don't control, you can make your local API much cleaner and more native. Doing this however comes with a few challenges. One is that you have to map a local attribute name to a remote attribute name, because Perl uses underscores, and Java uses camel case, e.g <code>postal_code and postalCode</code>. The second problem is that many times the value of the attribute in its perl native form is not what the remote wants, e.g. perl boolean "1" remote "Y", or a <a href="https://metacpan.org/module/DateTime">DateTime</a> object to W3C formatting. This second is not quite the same as mapping, because mapping is one to one, this translation could be turning an array into a comma separated string. The third problem, I didn't run into until after I "solved" the first , is how should I deal with nested complex objects (one's that can't be just converted to just a string). </p><p>My first naive remote facade was very procedural and simply assembled top to bottom, in part because it was based on <a href="https://metacpan/module/SOAP::Lite">SOAP::Lite</a>, and in part because I had yet to figure out a better way. This resulted in a giant unwieldy if/then chain. Obviously my translations were just inline too. </p><p>The next thing I tried was using triggers to construct a request hash to pass to <a href="https://metacpan/module/XML::Compile::SOAP">XML::Compile::SOAP</a>. This worked better as the hash constructing code was kept right next to the attribute, so if I needed to modify the local or remote attribute, I could just go look at the attribute and the trigger tied to it. </p><p>After that I tried to use a <a href="http://perldoc.perl.org/functions/map.html">map</a> to translate from the native attribute name to the remote attribute name. This may have been more successful had it worked more like the <a href="http://martinfowler.com/eaaCatalog/remoteFacade.html">Assembler in the Remote Facade</a>. But ult imately since we were developing a rapidly changing API it seemed to bog me down, this is because I was changing the attributes on both sides of the mapping and thus the mapping at the same time (so at least 3 places). Here I was just manually dealing with the translation from a W3C DateTime format to the object I needed. </p><h2>a solution</h2><p>When I got assigned to yet another API and found myself doing yet another mapping and translation I decided that I needed to solve the problem. Enter the first iteration of <a href="https://metacpan.org/module/MooseX::RemoteHelper">MooseX::RemoteHelper</a>. The first tie I used it with the form-url-encoded API so it was only needed for a single level of key, value pairs. .</p><script src="https://gist.github.com/2822416.js"> </script><noscript><pre><code><br />package MessagePart {<br />    use Moose 2;<br />    use MooseX::RemoteHelper;<br />    with 'MooseX::RemoteHelper::CompositeSerialization';<br /><br />    has array => (<br />        remote_name => 'SomeColonDelimitedArray',<br />        isa        => 'ArrayRef',<br />        is         => 'ro',<br />        serializer => sub {<br />            my ( $attr, $instance ) = @_;<br />            return join( ':', @{ $attr->get_value( $instance ) } );<br />        },<br />    );<br /><br />    __PACKAGE__->meta->make_immutable;<br />}<br /></code><br /></pre></noscript><p>Once I determined how to create MX::RemoteHelper it was simply a matter of using <a href="https://metacpan.org/module/Class::MOP::Class">Class::MOP::Class</a> API's to iterate all the attributes.  The source of <a href="https://github.com/xenoterracide/MooseX-RemoteHelper/blob/master/lib/MooseX/RemoteHelper/CompositeSerialization.pm">CompositeSerialization</a> will give you some idea of how I did this. </p><p>Then I went back to apply this to a previous module, because the technique appears to be cleaner. Unfortunately I ran into a problem, this other API was a complex data structure, and how best to provide nested hashrefs and arrayrefs. Though I was now armed with Patterns I didn't know of one that would solve the problem. Fortunately a quick flip through the <a href="http://www.amazon.com/gp/product/0201633612/ref=as_li_ss_tl?ie=UTF8&tag=xenotsblog-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0201633612">Gang of Four</a><img src="http://www.assoc-amazon.com/e/ir?t=xenotsblog-20&l=as2&o=1&a=0201633612" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> brought me to the <a href="http://en.wikipedia.org/wiki/Composite_pattern">Composite Pattern</a>. I used this to write the recursive <a href="https://github.com/xenoterracide/MooseX-RemoteHelper/blob/master/lib/MooseX/RemoteHelper/CompositeSerialization.pm">CompositeSerialization</a> so that if I had a sufficiently complex nested structure I could simply create another object to deal with that. Here's a full example: <script src="https://gist.github.com/2822109.js"> </script><noscript><pre><code>use 5.014;<br />use warnings;<br />use Data::Dumper;<br /><br />package MessagePart {<br />    use Moose;<br />    use MooseX::RemoteHelper;<br />    with 'MooseX::RemoteHelper::CompositeSerialization';<br /><br />    has array => (<br />        remote_name => 'SomeColonDelimitedArray',<br />        isa      => 'ArrayRef',<br />        is        => 'ro',<br />        serializer => sub {<br />            my ( $attr, $instance ) = @_;<br />            return join( ':', @{ $attr->get_value( $instance ) } );<br />        },<br />    );<br /><br />    __PACKAGE__->meta->make_immutable;<br />}<br />    <br />package Message {<br />    use Moose;<br />    use MooseX::RemoteHelper;<br /><br />    with 'MooseX::RemoteHelper::CompositeSerialization';<br /><br />    has bool => (<br />        remote_name => 'Boolean',<br />        isa      => 'Bool',<br />        is        => 'ro',<br />        serializer => sub {<br />            my ( $attr, $instance ) = @_;<br />            return $attr->get_value( $instance ) ? 'Y' : 'N';<br />        },<br /><br />    );<br /><br />    has foo_bar => (<br />        remote_name => 'FooBar',<br />        isa      => 'Str',<br />        is        => 'ro',<br />    );<br /><br />    has part => (<br />        isa      => 'MessagePart',<br />        remote_name => 'MyMessagePart',<br />        is        => 'ro',<br />    );<br /><br />    __PACKAGE__->meta->make_immutable;<br />}<br /><br />my $message<br />= Message->new({<br />    bool    => 0,<br />    foo_bar => 'Baz',<br />    part    => MessagePart->new({ array => [ qw( 1 2 3 4 ) ] }),<br />});<br /><br />say Dumper $message->serialize<br /></code><br /></pre></noscript>Which should give you this data structure: <script src="https://gist.github.com/2822552.js"> </script><noscript><pre><code>{<br />  Boolean => "N",<br />  FooBar => "Baz",<br />  MyMessagePart => {<br />    SomeColonDelimitedArray => "1:2:3:4"<br />  }<br />}<br /></code><br /></pre></noscript></p><h2>Request For Comment</h2><p>I've recently released a <a href="http://search.cpan.org/~xeno/MooseX-RemoteHelper-0.001010-TRIAL/lib/MooseX/RemoteHelper.pm">Trial version of MooseX::RemoteHelper</a> to CPAN. I'm currently refactoring <a href="https://metacpan.org/module/Business::CyberSource">Business::CyberSource</a> to use it, and it appears to be solid. What I'd like to know what people think of the module names, method names and any other comments they might have. I haven't been entirely sure that I've been naming things correctly while writing this, or that the code couldn't be better in other ways. If there's functionality you wish it had but doesn't let me know. </p><div class="blogger-post-footer"><br />--<br />
This <span xmlns:dc="http://purl.org/dc/elements/1.1/" href="http://purl.org/dc/dcmitype/Text" rel="dc:type">work</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://www.xenoterracide.com" property="cc:attributionName" rel="cc:attributionURL">Caleb Cushing</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.</div>
